---
title: "Introduction to Boundingbox"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to Boundingbox}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

When we create bounding boxes in images, particularly if we intend to feed them into predictive models, we are often:

* Processing many images
* Classifying the contents of the bounding boxes
* Standardizing the size of the images
* Capturing the coordinates


The **boundingbox** package supports these activities in efficient and effective ways:

* It allows you to stream your images from a directory for processing, in batches if desired.
* It allows you to set a common classifier for all images, or select a classifier per bounding box.
* It allows you to resize all of the output images to be the same size.
* It outputs a dataframe of the coordinates along with other metadata points.

This document explains when and how to use the two primary functions **boxer** and **boxer2** to generate bounding boxes, and the auxilary function **outBox** to output the images. 


## boxer()

The **boxer** function allows you to stream through images (JPEG, PNG, BMP) from a directory.  As each image appears, indicate between 2 and 26 points around which **boxer** will calculate a bounding box. The name of the original file, the bounding box coordinates, and optional image resize values, classifier and box color are returned in a dataframe. **boxer** also offers the option to call the **outBox** function that will output each image with its bounding box. If outputting the images, the show_classifier parameter controls whether or not to show the class as a label above the bounding box.


### Example
``` {r, echo = TRUE, eval = FALSE}
box_coords <- boxer(names = c("dog1.jpg", "dog2.jpg"), file_path_input = "/dog_pics/input/", 
                    file_path_output = "/dog_pics/output/", classifier = "dog", 
                    show_classifier = T, resize_x = 224, resize_y = 224, outpics = T)
```
When an image appears, use the left mouse button to select a point, and the right mouse button to signal completion and to move to the next image. To skip through any of the images, use the right mouse button prior to selecting any points with the left button. If the selected point goes out of the bounds of the image, the x and/or y coordinate is adjusted to the nearest set of coordinates on the inside edge of the image. 

Here is a screen shot of the first image with several points selected and the output file generated with a bounding box based on the selected points

```{r, echo = FALSE, out.width = "250px", fig.show = 'hold'}
knitr::include_graphics("README-input-1.jpg")
knitr::include_graphics("README-output-1.jpg")
```

Here is a screen shot of the second image with two points selected and the output file generated with a bounding box based on the selected points

```{r, echo = FALSE, out.width = "250px", fig.show = 'hold'}
knitr::include_graphics("README-input-2.jpg")
knitr::include_graphics("README-output-2.jpg")
```

The resulting data frame will have the bounding box coordinates, the classifier, the image width and height, and box color for each of the images. Note that the y-coordinate extends from the top down, instead of the bottom up for these images. 

box_coords
```{r echo=FALSE, eval=TRUE}
box_coords <- data.frame(file_name = c("dog1.jpg", "dog2.jpg"), x_left = c(19,41), y_top = c(9,5), x_right = c(201, 149), y_bottom = c(223, 216), size_x = c(224, 224), size_y = c(224,224), classifier = "dog", color = "red", stringsAsFactors = F)
box_coords
```

If there is a large number of images to stream through, consider using the batch parameter which will give an option to truncate the stream at the fixed interval set. Otherwise if in the middle of the stream and you do not want to continue, there are two options. One is to right mouse click to skip through the remaining images. The dataframe of coordinates will be produced at the end. The other alternative is to force close the image viewer (for example, X Windows System) in which case the function will not complete and the coordinates for the generated bounding boxes will not be produced. 

In the event you do truncate the process before you get to the last image and you want to pick up where you left off, be mindful of the following points. First, you will want to subset the vector of image file names such that it only includes the remaining images. Second, you will want to change the name you give to the output ("boxcoords" in the example above) so that you do not overwrite your earlier work. 


## boxer2()

The **boxer2** function operates in the same way as **boxer**, however, it gives you the option to add multiple bounding boxes per image, and to select the classifier per bounding box. To support the classifier selection, you need to provide a dataframe for the classifier parameter.

### Example
``` {r, echo = TRUE, eval = FALSE}
dog_df <- data.frame(ref = (1:2), class = c("Skip", "Waltz"), color = c("red","yellow"), stringsAsFactors = F)

box_coords2 <- boxer2(names = c("SW1.png"), file_path_input = "/dog_pics/input/", 
                    file_path_output = "/dog_pics/output/", classifier = dog_df, 
                    show_classifier = T, outbox = T)
```

After selecting the points for an image, you will be given the prompt below at which you enter the numeric "ref" value from the classifier dataframe that corresponds to the bounding box. 
> "Enter ref# for the classifier of this bounding box "

Then you will be given this prompt to confirm if you want to add another box to the same image or move on to the next.
>"Enter 1 to add bounding box to same image, any other key for next image "

Because the function pauses at each prompt, it will take more time to get through each image than with **boxer**.  If all of the images are of the same classifier and only one box per image, **boxer** is the more efficient function.

Output from **boxer2** with multiple bounding boxes and classifiers in one image.

```{r, echo = FALSE, out.width = "250px"}
knitr::include_graphics("README-output-3.png")
```

box_coords2
```{r echo=FALSE, eval=TRUE}
box_coords2 <- data.frame(file_name = c("SW1.png", "SW1.png"), x_left = c(0, 157), y_top = c(9, 123), x_right = c(122, 284), y_bottom = c(110, 245), size_x = c(286, 286), size_y = c(320, 320), classifier = c("Waltz", "Skip"), color = c("yellow", "red"), stringsAsFactors = F)
box_coords2
```


## outBox()

The **outBox** function generates the output images. It can be called by setting the parameter *outbox = T* in **boxer** and **boxer2**. The output images will be generated to the directory indicated by the *file_path_output* parameter as the final step after the last image file is processed. Alternatively, you can keep the *outbox = F* default when running **boxer** and **boxer2** and feed the output dataframe to **outBox** separately. This you may want to do if you need to amalgamate dataframes, edit the data in any way, or have another way to generate the bounding box coordinates. If your dataframe of bounding box coordinates was not generated by **boxer** or **boxer2**, it needs to be in the same format as if it were. See box_coord and box_coord2 as examples above.

###Example
``` {r, echo = TRUE, eval = FALSE}
outBox(points_master = box_coords2, file_path_input = "/dog_pics/input/", 
    'file_path_output = "/dog_pics/output/", show_classifier = T)
```



